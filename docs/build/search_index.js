var documenterSearchIndex = {"docs":
[{"location":"man/Loops/#Loops","page":"Loops","title":"Loops","text":"","category":"section"},{"location":"man/IsingGraphs/#IsingGraphs","page":"IsingGraphs","title":"IsingGraphs","text":"","category":"section"},{"location":"man/usage/#General-Usage","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"This package can be used to simulate 2-, 2.5- and 3D Ising models (any model with 1D state and where the couplings are at most linear.) with different algorithms and energy functions. The simulations are segmented in different layers which can be 2D or 3D (at this moment there's only support for rectangular and cuboid layers).","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The base datastructure for every simulation is the IsingGraph, which holds all the data neccesary for the simulation to run, such as the state, the adjacency list, other parameters (like the magnetic field or other parameters in the energy function) and metadata for the layers, among other things.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The layers are an abstraction on top of the basic IsingGraph, and are the structures the user will mainly interact. Any layer in itself can be interpreted as an Ising Model with it's own properties. Currently the library supports layers that have continuous or discrete states. For both of these types a \"state set\" can be defined. For continuous layers the stateset may consist of two numbers which are interpreted as the end points of a closed interval. The states of any spin may then take on values from anywhere in this interval. For discrete states, the stateset may consist of any amount of numbers, and the spins in the system may take any of the values in the set.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can create an empty graph by calling the constructor for the IsingGraph","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"# Construct Empty Graph\ng = IsingGraph()","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"In this guide we will add everything step by step, but there are additional constructors to instantiate a graph with layers in place already. See IsingGraphs for more information.","category":"page"},{"location":"man/usage/#Adding-Layers","page":"General Usage","title":"Adding Layers","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can add layers one by one in the following way","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"#addLayer!(len, width, [height]; set, type)\n#Add a 2D layer\naddLayer!(g, 250,250, set = (-1,1), type = Continuous)\n...","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The exlamation mark denotes that this function is altering data in the struct it is being passed (in this case the graph g), as per general convention. The keyword argument in square brackets '[]' is optional. The arguments behind the semicolon ';' are keyword arguments that have to be explicitly given by writing the name followed by an equals sign '='.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"By default, these layers have no connections internally, or to other layers.","category":"page"},{"location":"man/usage/#Accessing-the-layers","page":"General Usage","title":"Accessing the layers","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Now that our IsingGraph contains multiple layers, when we want to interact with the graph, we typically do so through these layers directly instead of with the graph itself (since the graph is a more abstract representation). We can access the layers of a graph through vector indexing of the graph. E.g., we can access the n-th layer of a graph as follows","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"layer_n = g[n]","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where n is some integer.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Most functions that work on an IsingGraph also work on an IsingLayer directly. However, if we refer to a spin in the graph or a spin in the layer the index we use to refer to a spin typically is different.","category":"page"},{"location":"man/usage/#Indexing-the-spins","page":"General Usage","title":"Indexing the spins","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The final state that is updated is held in a long vector stored in the IsingGraph. The layers, then, hold references to a part of this long vector and are interpreted as 2D or 3D structures. As an example we can have a 3, 2D layer IsingGraph","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"g equiv","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"[s_1s_N_1s_N_1 + 1  s_N_2  ","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The spins s_N_1 + 1  s_N_2 correspond to all the spins in the second layer. This second layer has a 2D dimension of L_2*W_2 = N_2 - (N_1 + 1) where we define the length L to be the vertical dimension and the width W the horizontal dimension. Thus we may interpret this part of the vector in the graph, indexed by a single index, as a 2D matrix in the layer, which we can access by giving two coordinates i,j. The coordinates correspond the the index in the following way (known in CS as column-major order): index = (((i-1) mod L) + 1 + L*j). In other words, every integer value for j","category":"page"},{"location":"man/usage/#Generating-the-weights","page":"General Usage","title":"Generating the weights","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The connections can be generated using a WeightGenerator. A weightgenerator must be constructed using the macro @WG. A weightgenerator is a struct that can be used to get a weight based on an arbitrary function of any combination of the following arguments: [:dr, :x, :y, :z, :dx, :dy, :dz], where dr is the relative distance between two spins, x, y and z are the midpoints between two spins that a weight is connecting (counted from the left top) and dx dy and dz are the separate one dimensional, relative distances between two spins. A weight generator expects a string containing a julia anonymous function in the following way","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"# Create the weightgenerator\nwg = @WG \"(dr) -> 1/dr^2\"","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"A weightgenerator can also include additive or multiplicative noise based on arbitrary distributions. See the WeightGenerator page for more information.","category":"page"},{"location":"man/usage/#Setting-Defects","page":"General Usage","title":"Setting Defects","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"When the simulation is started, the simulation loop is aware at the start which spins may be updated. Generally this will include every spin, but we can let the simulation know it should only loop over a collection of spins, effectively freezing the others. This will cause a small performance hit, because choosing a spin from a continuous range is less expensive than choosing one from a list, but generally the effect should be small and mostly independent on the size of the list.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can set defect with the following function","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"setDefects!(g::AbstractIsingGraph, bool, idxs)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where an AbstractIsingGraph can be either an IsingGraph or an IsingLayer. I.e. spins may be set using the list index of the underlying graph, or using the list index of a specific layer.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"If bool == true, then we indicate the spins at the given indexes should be considered as defect (i.e. non-updating), whereas bool == false indicates the spins may be updated again.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"In some sense the list of defects may be considered as metadata, meaning that it's just information that may be used by an algorithm, but doesn't neccesarily have to be used. In other words, the specific algorithm being used may still update the defect spins, or for example use the list of defects to apply a different type of update to those spins. It all depends on how the algorithm is implemented to use this data.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We may directly set spins to a value and set them to be defect or conversely updating using","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"setSpins!(g::AbstractIsingGraph, idx::Integer, brush::Real, clamp::Bool = false)","category":"page"},{"location":"man/usage/#Starting-the-simulation","page":"General Usage","title":"Starting the simulation","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"When the graph is updated using the built in simulation, it refers to a simulation struct that's held in the module. A user typically doesn't need to interact with this struct directly. It holds data for the windows that are open, the multiple threads being used for simulation loops on a single graph or multiple different ones, etc.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Now that we have set up the graph, we typically start a simple simulation with the following function","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"simulate(g::IsingGraph, gui = true)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where the optional keyword argument gui may be given to opt out of starting the graphical user interface (this may be useful if custom display options need to be used).","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The interface, and handling of julia commands all run on a separate thread from the simulation loop itself. Any updating algorithm is typically run on a separate thread on the computer, which updates the graph asynchronously. I.e. in this setup a user will not be sure exactly on which loop interaction will happen.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Any of the algorithms that are deployed, depend on a so called loop function. At this moment the only loop function is the mainLoop function, which is just a loop that runs indefinitely. Support for a loop function that loops for a predefined number of iterations after which it will run given analysis functions, will be added. For more information on how the loops work, see Loops","category":"page"},{"location":"man/usage/#Interacting-with-the-simulation-loop","page":"General Usage","title":"Interacting with the simulation loop","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Once we have a simulation running, we might want to pause, restart it with different parameters or a different algorithm or stop it completely for a while.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Generally we can pause using the function","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"pause(g)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"after which it can be resumed with","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"unpause(g)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"<!– We can also completely quit the simulation though this is generally not rec","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"quit(g)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"–>","category":"page"},{"location":"man/usage/#Interacting-with-parameters","page":"General Usage","title":"Interacting with parameters","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Hamiltonians, and sometimes the algorithms themselves, might have parameters that either have a physical interpretation or some technical interpretation in terms of the simulation itself. Moreover, these parameters might be accesible to the user to change during runtime, like the magnetic field on the spins, or a clamping factor for equilibrium propagation.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Parameters will be either of scalar of vector value. In the case of a vector value, every index of the vector will correspond one-to-one to a spin.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Since the parameters that are in the graph will depend on the simulation loop and hamiltonian, all of which can be changed during runtime, they are not put in place when the graph is created (this might change), but rather when the simulation is started. Every time a simulation is started or restarted, the simulation loop will check if all the neccesary parameters are in place.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"These parameters may all be accesed through the accessor function params(g). This will print out a list of parameters, which are referred to by a julia symbol, along with an explanation, whether it should be used by a simulation loop, and what its current value is (it may be scalar or vector valued).","category":"page"},{"location":"man/usage/#Default-values","page":"General Usage","title":"Default values","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Since accessing memory is generally costly in computation time, acessing many parameters will generally cause a simulation loop to slow down. In other words, even if for some simulation a magnetic field is never considered, having the option to set a magnetic field would cause a slow down regardless of wether it is used. This is why these parameters are wrapped in a ParamVal type, which holds extra information, i.e. what a default global value is for the parameter in question, and wether it should be considered in the simulation.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Using Julias metaprogramming capabilities simulation loops may substitute the global value for a parameter into the loop itself instead of acessing memory, in the case where a parameter is noted as not being active. This has a downside, in that the simulation needs to be paused and recompiled when the active status of a parameter is changed, or the global value it has. In other words, we made a trade-off between simulation speed and startup/restart time, in favor of simulation speed. In the most optimal case, this also causes extra overhead when writing new simulation loops or Hamiltonians, since metaprogramming is needed. However, a simulation loop may opt out of using the active status of a parameter altogether, so that prototyping new algorithms still has the same amount of overhead.","category":"page"},{"location":"man/usage/#Setting-and-getting-parameters","page":"General Usage","title":"Setting and getting parameters","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Since the parameters contain information in their types for the simulation to use, which requires recompilation of the loop if changed, it is generally not advised to directly change the data in the parameters itself. Instead we provide the function setParam!, which automatically handles recompilation of running loops.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"setParam!(g::AbstractIsingGraph, param::Symbol, val::T, active::Bool = nothing)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where T either is either of the same type of the value of the parameter itself, or in the case that the ParamVal holds a vector value, it may be of the element type of that vector, in which case the whole vector is globally set to the same value. In the latter case the user may also opt to deactivate the param and set a global value. This is only advised if the value is not changed often, since every change then causes recompilation of the loop. param here is a julia symbol that refers to the parameter that the user wants to change. g can be a graph or a layer, which only matters for vector values. In the layer case, we may give a scalar, a vector or a matrix as val. If a scalar is given it sets a every value corresponding to a spin in that layer to the same value when a scalar is given. For a vector, the function expects a vector with length equal to the number of spins in the layer. Lastly, for the matrix, it must be of the same size of the layer.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Finally if the optional argument active is given it will change wether value of that parameter should be accessed during runtime in the simulation loop. If this argument is not provided, it will keep the previous active status.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"To immediately get the parameter of corresponding to a symbol, we can use","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"getParam(g::AbstractIsingGraph, param::Symbol)","category":"page"},{"location":"man/WeightGenerator/#WeightGenerator","page":"WeightGenerator","title":"WeightGenerator","text":"","category":"section"}]
}
