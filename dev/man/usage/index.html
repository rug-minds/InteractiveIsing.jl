<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General Usage · InteractiveIsing Documentation</title><meta name="title" content="General Usage · InteractiveIsing Documentation"/><meta property="og:title" content="General Usage · InteractiveIsing Documentation"/><meta property="twitter:title" content="General Usage · InteractiveIsing Documentation"/><meta name="description" content="Documentation for InteractiveIsing Documentation."/><meta property="og:description" content="Documentation for InteractiveIsing Documentation."/><meta property="twitter:description" content="Documentation for InteractiveIsing Documentation."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>InteractiveIsing Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>General Usage</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#General-Usage"><span>General Usage</span></a></li><li><a class="tocitem" href="#Adding-Layers"><span>Adding Layers</span></a></li><li><a class="tocitem" href="#Accessing-the-layers"><span>Accessing the layers</span></a></li><li><a class="tocitem" href="#Indexing-the-spins"><span>Indexing the spins</span></a></li><li><a class="tocitem" href="#Generating-the-weights"><span>Generating the weights</span></a></li><li><a class="tocitem" href="#Setting-Defects"><span>Setting Defects</span></a></li><li><a class="tocitem" href="#Starting-the-simulation"><span>Starting the simulation</span></a></li><li><a class="tocitem" href="#Interacting-with-the-simulation-loop"><span>Interacting with the simulation loop</span></a></li><li><a class="tocitem" href="#Interacting-with-parameters"><span>Interacting with parameters</span></a></li><li><a class="tocitem" href="#Algorithms-and-Hamiltonians"><span>Algorithms and Hamiltonians</span></a></li></ul></li><li><span class="tocitem">Details</span><ul><li><a class="tocitem" href="../IsingGraphs/">IsingGraphs</a></li><li><a class="tocitem" href="../Indexing/">Indexing</a></li><li><a class="tocitem" href="../WeightGenerator/">WeightGenerators</a></li><li><a class="tocitem" href="../GeneratingAdj/">Generating Adjacency Lists</a></li><li><a class="tocitem" href="../Defects/">Defects</a></li><li><a class="tocitem" href="../Loops/">Loops</a></li><li><a class="tocitem" href="../Parameters/">Parameters</a></li><li><a class="tocitem" href="../Algorithms/">Algorithms</a></li><li><a class="tocitem" href="../Hamiltonians/">Hamiltonians</a></li><li><a class="tocitem" href="../Analysis/">Analysis</a></li><li><a class="tocitem" href="../Processes/">Processes</a></li><li><a class="tocitem" href="../Topology/">Topology</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>General Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rug-minds/InteractiveIsing.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rug-minds/InteractiveIsing.jl/blob/main/docs/src/man/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Before-Using"><a class="docs-heading-anchor" href="#Before-Using">Before Using</a><a id="Before-Using-1"></a><a class="docs-heading-anchor-permalink" href="#Before-Using" title="Permalink"></a></h1><p>This package aims to offer interactive simulations that run at the maximal speed Julia has to offer. Due to the nature of interactive simulations, we need multithreading. Therefore, starting up julia as normal (which defaults to 1 thread), will cause freezing when trying to use this package.</p><p>To start julia up, either start it from a terminal with multiple threads (at least 8 should be supported on many modern CPU&#39;s)</p><pre><code class="nohighlight hljs">julia --threads 8</code></pre><p>or add an environment variable (this depends on the operating system)</p><pre><code class="nohighlight hljs">JULIA_NUM_THREADS=8</code></pre><p>When using through VSCode, add the following setting:</p><pre><code class="nohighlight hljs">&quot;julia.NumThreads&quot; : &quot;8&quot;</code></pre><p>If you experience hanging still on certain operations, start with</p><pre><code class="nohighlight hljs">&quot;julia.NumThreads&quot; : &quot;7,1&quot;</code></pre><h1 id="General-Usage"><a class="docs-heading-anchor" href="#General-Usage">General Usage</a><a id="General-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#General-Usage" title="Permalink"></a></h1><p>This package can be used to simulate 2-, 2.5- and 3D Ising models (any model with 1D state and where the couplings are at most linear.) with different algorithms and energy functions. The simulations are segmented in different layers which can be 2D or 3D (at this moment there&#39;s only support for rectangular and cuboid layers).</p><p>The base datastructure for every simulation is the IsingGraph, which holds all the data neccesary for the simulation to run, such as the state, the adjacency list, other parameters (like the magnetic field or other parameters in the energy function) and metadata for the layers, among other things.</p><p>The layers are an abstraction on top of the basic IsingGraph, and are the structures the user will mainly interact. Any layer in itself can be interpreted as an Ising Model with it&#39;s own properties. Currently the library supports layers that have continuous or discrete states. For both of these types a &quot;state set&quot; can be defined. For continuous layers the stateset may consist of two numbers which are interpreted as the end points of a closed interval. The states of any spin may then take on values from anywhere in this interval. For discrete states, the stateset may consist of any amount of numbers, and the spins in the system may take any of the values in the set.</p><p>We can create an empty graph by calling the constructor for the IsingGraph</p><pre><code class="nohighlight hljs"># Construct Empty Graph
g = IsingGraph()</code></pre><p>In this guide we will add everything step by step, but there are additional constructors to instantiate a graph with layers in place already. See <a href="../IsingGraphs/#IsingGraphs">IsingGraphs</a> for more information.</p><h2 id="Adding-Layers"><a class="docs-heading-anchor" href="#Adding-Layers">Adding Layers</a><a id="Adding-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Layers" title="Permalink"></a></h2><p>We can add layers one by one in the following way</p><pre><code class="nohighlight hljs">#addLayer!(len, width, height = nothing; set, type)
#Add a 2D layer
addLayer!(g, 250,250, set = (-1,1), type = Continuous)
...</code></pre><p>The exlamation mark denotes that this function is altering data in the struct it is being passed (in this case the graph g), as per general convention. The argument height is optional, and if not the function produces a 2D layer. The arguments behind the semicolon &#39;;&#39; are keyword arguments that have to be explicitly given by writing the name followed by an equals sign like shown.</p><p>By default, these layers have no connections internally or to other layers.</p><h2 id="Accessing-the-layers"><a class="docs-heading-anchor" href="#Accessing-the-layers">Accessing the layers</a><a id="Accessing-the-layers-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-the-layers" title="Permalink"></a></h2><p>Now that our IsingGraph contains multiple layers, when we want to interact with the graph, we typically do so through these layers directly instead of with the graph itself (since the graph is a more abstract representation). We can access the layers of a graph through vector indexing of the graph. E.g., we can access the n-th layer of a graph as follows</p><pre><code class="nohighlight hljs">layer_n = g[n]</code></pre><p>where n is some integer.</p><p>Most functions that work on an IsingGraph also work on an IsingLayer directly. However, if we refer to a spin in the graph or a spin in the layer the index we use to refer to a spin typically is different.</p><h2 id="Indexing-the-spins"><a class="docs-heading-anchor" href="#Indexing-the-spins">Indexing the spins</a><a id="Indexing-the-spins-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-the-spins" title="Permalink"></a></h2><p>The final state that is updated is held in a long vector stored in the IsingGraph. The layers, then, hold references to a part of this long vector and are interpreted as 2D or 3D structures. As an example we can have an IsingGraph with 3 2D layers,</p><p class="math-container">\[g \equiv [s_1,...,s_{N_1},s_{N_1 + 1}, ..., s_{N_2}, ... ]\]</p><p>where, for example, spins <span>$s_{N_1 + 1}, ..., s_{N_2}$</span> would all belong to the second layer. This second layer has a 2D dimension of <span>$L_2*W_2 = N_2 - (N_1 + 1)$</span> where we define the length <span>$L$</span> to be the vertical dimension and the width <span>$W$</span> the horizontal dimension. Thus we may interpret this part of the vector in the graph, indexed by a single index, as a 2D matrix in the layer, which we can access by giving two coordinates i,j. The coordinates correspond the the index in the following way (known in CS as column-major order): <span>$index = \left( ( (i-1) mod L) + 1 + L*j \right)$</span>. In words, when we iterate through values of <span>$i$</span>, we cycle through numbers <span>$1$</span> to <span>$50$</span>, and for every value of <span>$j$</span> we add <span>$50$</span> to that to get the index.</p><p>See <a href="../Indexing/#Indexing">Indexing</a> for supporting functions.</p><h2 id="Generating-the-weights"><a class="docs-heading-anchor" href="#Generating-the-weights">Generating the weights</a><a id="Generating-the-weights-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-the-weights" title="Permalink"></a></h2><p>The connections for a layer and between layers can be generated using a <a href="../WeightGenerator/#WeightGenerator">WeightGenerator</a>. A weightgenerator must be constructed using the macro <code>@WG</code>. A weightgenerator is a struct that can be used to get a weight based on an arbitrary function of any combination of the following arguments: <code>[:dr, :x, :y, :z, :dx, :dy, :dz]</code>, where dr is the relative distance between two spins, x, y and z are the midpoints between two spins that a weight is connecting (counted from the left top) and dx dy and dz are the separate one dimensional, relative distances between two spins. A weight generator expects a string containing a julia anonymous function in the following way</p><pre><code class="nohighlight hljs"># Create the weightgenerator
wg_Ising = @WG &quot;dr == 1 ? 1 : 0&quot; NN = 1 # Ising Connections, taking into account only connections 1 spin apart in any direction

wg = @WG &quot;(dr) -&gt; 1/dr^2&quot; NN = (2,3) #Arbitrary function with two nearest neighbors in x direction, 3 in y</code></pre><p>A weightgenerator can also include additive or multiplicative noise based on arbitrary distributions. See the <a href="../WeightGenerator/#WeightGenerator">WeightGenerator</a> page for more information on the usage.</p><p>To now generate and set the connections within layer <code>i</code> we use the function</p><pre><code class="nohighlight hljs">genAdj!(g[i], wg)</code></pre><h2 id="Setting-Defects"><a class="docs-heading-anchor" href="#Setting-Defects">Setting Defects</a><a id="Setting-Defects-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Defects" title="Permalink"></a></h2><p>When the simulation is started, the simulation loop is aware at the start which spins may be updated. Generally this will include every spin, but we can let the simulation know it should only loop over a collection of spins, effectively freezing the others. This will cause a small performance hit, because choosing a spin from a continuous range is less expensive than choosing one from a list, but generally the effect should be small and mostly independent on the size of the list.</p><p>We can set defect with the following function</p><pre><code class="nohighlight hljs">setDefects!(g::AbstractIsingGraph, bool, idxs)</code></pre><p>where an AbstractIsingGraph can be either an IsingGraph or an IsingLayer. I.e. spins may be set using the list index of the underlying graph, or using the list index of a specific layer.</p><p>If <code>bool == true</code>, then we indicate the spins at the given indexes should be considered as defect (i.e. non-updating), whereas <code>bool == false</code> indicates the spins may be updated again.</p><p>In some sense the list of defects may be considered as metadata, meaning that it&#39;s just information that may be used by an algorithm, but doesn&#39;t neccesarily have to be used. In other words, the specific algorithm being used may still update the defect spins, or for example use the list of defects to apply a different type of update to those spins. It all depends on how the algorithm is implemented to use this data.</p><p>We may directly set spins to a value and set them to be defect or conversely updating using</p><pre><code class="nohighlight hljs">setSpins!(g::AbstractIsingGraph, idx::Integer, brush::Real, clamp::Bool = false)</code></pre><p>For more information see <a href="../Defects/#Defects">Defects</a></p><h2 id="Starting-the-simulation"><a class="docs-heading-anchor" href="#Starting-the-simulation">Starting the simulation</a><a id="Starting-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-the-simulation" title="Permalink"></a></h2><p>When the graph is updated using the built in simulation, it refers to a simulation struct that&#39;s held in the module. A user typically doesn&#39;t need to interact with this struct directly. It holds data for the windows that are open, the multiple threads being used for simulation loops on a single graph or multiple different ones, etc.</p><p>Now that we have set up the graph, we typically start a simple simulation with the following function</p><pre><code class="nohighlight hljs">simulate(g::IsingGraph, gui = true)</code></pre><p>where the optional keyword argument <code>gui</code> may be given to opt out of starting the graphical user interface (this may be useful if custom display options need to be used).</p><p>The interface, and handling of julia commands all run on a separate thread from the simulation loop itself. Any updating algorithm is typically run on a separate thread on the computer, which updates the graph asynchronously. I.e. in this setup a user will not be sure exactly on which loop interaction will happen.</p><p>Any of the algorithms that are deployed, depend on a so called loop function. At this moment the only loop function is the mainLoop function, which is just a loop that runs indefinitely. Support for a loop function that loops for a predefined number of iterations after which it will run given analysis functions, will be added. For more information on how the loops work, see <a href="../Loops/#Loops">Loops</a></p><h2 id="Interacting-with-the-simulation-loop"><a class="docs-heading-anchor" href="#Interacting-with-the-simulation-loop">Interacting with the simulation loop</a><a id="Interacting-with-the-simulation-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Interacting-with-the-simulation-loop" title="Permalink"></a></h2><p>Once we have a simulation running, we might want to pause, restart it with different parameters or a different algorithm or stop it completely for a while.</p><p>Generally we can pause using the function</p><pre><code class="nohighlight hljs">pause(g)</code></pre><p>after which it can be resumed with</p><pre><code class="nohighlight hljs">unpause(g)</code></pre><p>We can also completely quit the simulation though this is generally not recommended</p><pre><code class="nohighlight hljs">quit(g)</code></pre><h2 id="Interacting-with-parameters"><a class="docs-heading-anchor" href="#Interacting-with-parameters">Interacting with parameters</a><a id="Interacting-with-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Interacting-with-parameters" title="Permalink"></a></h2><p>Hamiltonians, and sometimes the algorithms themselves, might have parameters that either have a physical interpretation or some technical interpretation in terms of the simulation itself. Moreover, these parameters might be accesible to the user to change during runtime, like the magnetic field on the spins, or a clamping factor for equilibrium propagation.</p><p>Parameters will be either of scalar of vector value. In the case of a vector value, every index of the vector will correspond one-to-one to a spin.</p><p>Since the parameters that are in the graph will depend on the simulation loop and hamiltonian, all of which can be changed during runtime, they are not put in place when the graph is created (this might change), but rather when the simulation is started. Every time a simulation is started or restarted, the simulation loop will check if all the neccesary parameters are in place.</p><p>These parameters may all be accesed through the accessor function <code>params(g)</code>. This will print out a list of parameters, which are referred to by a julia symbol, along with an explanation, whether it should be used by a simulation loop, and what its current value is (it may be scalar or vector valued).</p><h3 id="Default-values"><a class="docs-heading-anchor" href="#Default-values">Default values</a><a id="Default-values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-values" title="Permalink"></a></h3><p>Since accessing memory is generally costly in computation time, acessing many parameters will generally cause a simulation loop to slow down. In other words, even if for some simulation a magnetic field is never considered, having the option to set a magnetic field would cause a slow down regardless of wether it is used. This is why these parameters are wrapped in a <code>ParamVal</code> type, which holds extra information, i.e. what a default global value is for the parameter in question, and wether it should be considered in the simulation.</p><p>Using Julias metaprogramming capabilities simulation loops may substitute the global value for a parameter into the loop itself instead of acessing memory, in the case where a parameter is noted as not being active. This has a downside, in that the simulation needs to be paused and recompiled when the active status of a parameter is changed, or the global value it has. In other words, we made a trade-off between simulation speed and startup/restart time, in favor of simulation speed. In the most optimal case, this also causes extra overhead when writing new simulation loops or Hamiltonians, since metaprogramming is needed. However, a simulation loop may opt out of using the active status of a parameter altogether, so that prototyping new algorithms still has the same amount of overhead.</p><h3 id="Setting-and-getting-parameters"><a class="docs-heading-anchor" href="#Setting-and-getting-parameters">Setting and getting parameters</a><a id="Setting-and-getting-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-and-getting-parameters" title="Permalink"></a></h3><p>Since the parameters contain information in their types for the simulation to use, which requires recompilation of the loop if changed, it is generally not advised to directly change the data in the parameters itself. Instead we provide the function <code>setparam!</code>, which automatically handles recompilation of running loops.</p><pre><code class="nohighlight hljs">setparam!(g::AbstractIsingGraph, param::Symbol, val::T, active::Bool = nothing)</code></pre><p>where <code>T</code> either is either of the same type of the value of the parameter itself, or in the case that the <code>ParamVal</code> holds a vector value, it may be of the element type of that vector, in which case the whole vector is globally set to the same value. In the latter case the user may also opt to deactivate the param and set a global value. This is only advised if the value is not changed often, since every change then causes recompilation of the loop. <code>param</code> here is a julia symbol that refers to the parameter that the user wants to change. <code>g</code> can be a graph or a layer, which only matters for vector values. In the layer case, we may give a scalar, a vector or a matrix as val. If a scalar is given it sets a every value corresponding to a spin in that layer to the same value when a scalar is given. For a vector, the function expects a vector with length equal to the number of spins in the layer. Lastly, for the matrix, it must be of the same size of the layer.</p><p>Finally if the optional argument <code>active</code> is given it will change wether value of that parameter should be accessed during runtime in the simulation loop. If this argument is not provided, it will keep the previous active status.</p><p>To immediately get the parameter of corresponding to a symbol, we can use</p><pre><code class="nohighlight hljs">getparam(g::AbstractIsingGraph, param::Symbol)</code></pre><p>See <a href="../Parameters/#Parameters">Parameters</a> for more information.</p><h2 id="Algorithms-and-Hamiltonians"><a class="docs-heading-anchor" href="#Algorithms-and-Hamiltonians">Algorithms and Hamiltonians</a><a id="Algorithms-and-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-and-Hamiltonians" title="Permalink"></a></h2><p>Hamiltonians in this package are an abstract description of an energy function in terms of Julia symbols. They don&#39;t have any inherent code, and are only meant to symbolize the existense of that Hamiltonian in this package. The reason for this is the following: we want to support many different algorithms. These algorithms may require different quantities/functions derived from the Hamiltonian (such as a difference when changing the state of one unit or a derivative). Hardcoding the code for a Hamiltonian would not be efficient, and automating rewriting, or deriving quantities would still not give optimal performance, apart from being nigh impossible to implement for every algorithm.</p><p>Instead we have a system where the writer of an algorithm needs to implement a custom piece of code that implements the Hamiltonian for the specific algorithm. It is thus up to the writer of an algorithm to implement Hamiltonians.</p><p>For the user, different algorithms and Hamiltonians can be chosen. Moreover, algorithms can also implement composite Hamiltonians (<span>$H_{tot} = H_1 + H_2 + ...$</span>). </p><p>We can set a default algorithm to run when a new simulation is started (which can be manually overwritten when starting the simulation as well)</p><pre><code class="nohighlight hljs">default_algorithm(g, LayeredMetropolis)</code></pre><p>A new Hamiltonian can be set the following way</p><pre><code class="nohighlight hljs">hamiltonian(g,Ising)</code></pre><p>A composite Hamiltonian can be constructed from</p><pre><code class="nohighlight hljs">CompositeHamiltonian(Ising,Clamping)</code></pre><h3 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h3><p>The following algorithms are currently Implemented</p><ul><li><code>Metropolis</code>: The normal metropolis algorithm. This algorithm treats every layer to be of the same type as layer 1.</li><li><code>LayeredMetropolis</code>: An algorithm that implements a different algorithm for every layer based on the layer type. Due to metaprogramming it just reduces to the normal metropolis when all layers are of a single type.</li><li>Soon: <code>Langevin</code></li></ul><h3 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h3><p>Currently the following Hamiltonians are implemented</p><ul><li><code>Ising</code>: The Ising Hamiltonian <span>$H = - \sum_{ij} \sigma_i \sigma_j -\sum_i b_i \sigma_i$</span>   where <span>$b$</span> is the magnetic field at every spin</li><li><code>Clamping</code>: A Clamping Hamiltonian for Equilibrium Propagation <span>$H = β/2 *(s_i - y_i)^2$</span>   where <span>$y_i$</span> is a target value for the n-th spin</li><li><code>GaussianBernoulli</code>: The Gaussian Bernoulli Hamiltonian often used with RBM&#39;s </li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../IsingGraphs/">IsingGraphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Wednesday 4 September 2024 13:17">Wednesday 4 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
