var documenterSearchIndex = {"docs":
[{"location":"man/Algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/Hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"man/Hamiltonians/#Required-Hamiltonians","page":"Hamiltonians","title":"Required Hamiltonians","text":"","category":"section"},{"location":"man/Indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"man/Defects/#Defects","page":"Defects","title":"Defects","text":"","category":"section"},{"location":"man/IsingGraphs/#IsingGraphs","page":"IsingGraphs","title":"IsingGraphs","text":"","category":"section"},{"location":"man/IsingGraphs/","page":"IsingGraphs","title":"IsingGraphs","text":"The IsingGraphs{T <: AbstractFloat} are the main datastructure used for this module.","category":"page"},{"location":"man/IsingGraphs/","page":"IsingGraphs","title":"IsingGraphs","text":"The main datatypes in the IsingGraph relevant for runtime computations as the state and the adjacency list. They may be accessed through the accessor functions state(g) and adj(g) respectively. The subtype T is a Float and gives the precision for the state and weights.","category":"page"},{"location":"man/IsingGraphs/","page":"IsingGraphs","title":"IsingGraphs","text":"It also holds the temperature, but this may be moved to the layers.","category":"page"},{"location":"man/IsingGraphs/","page":"IsingGraphs","title":"IsingGraphs","text":"state returns a Vector{T} and adj a SparseMatrixCSC{T,Int32}.","category":"page"},{"location":"man/IsingGraphs/#The-State","page":"IsingGraphs","title":"The State","text":"","category":"section"},{"location":"man/IsingGraphs/#The-Adjacency-List","page":"IsingGraphs","title":"The Adjacency List","text":"","category":"section"},{"location":"man/IsingGraphs/#Setting-the-Hamiltonian","page":"IsingGraphs","title":"Setting the Hamiltonian","text":"","category":"section"},{"location":"man/IsingGraphs/#Setting-the-algorithm","page":"IsingGraphs","title":"Setting the algorithm","text":"","category":"section"},{"location":"man/Processes/#Processes","page":"Processes","title":"Processes","text":"","category":"section"},{"location":"man/GeneratingAdj/#Generating-Adjacency-Lists","page":"Generating Adjacency Lists","title":"Generating Adjacency Lists","text":"","category":"section"},{"location":"man/Parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/Interaction/#Interaction","page":"Interaction","title":"Interaction","text":"","category":"section"},{"location":"man/Topology/#Topology","page":"Topology","title":"Topology","text":"","category":"section"},{"location":"man/Topology/","page":"Topology","title":"Topology","text":"Layers will support custom topologies in the future that go beyond square lattices.","category":"page"},{"location":"man/Vis/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"man/usage/#General-Usage","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"This package can be used to simulate 2-, 2.5- and 3D Ising models (any model with 1D state and where the couplings are at most linear.) with different algorithms and energy functions. The simulations are segmented in different layers which can be 2D or 3D (at this moment there's only support for rectangular and cuboid layers).","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The base datastructure for every simulation is the IsingGraph, which holds all the data neccesary for the simulation to run, such as the state, the adjacency list, other parameters (like the magnetic field or other parameters in the energy function) and metadata for the layers, among other things.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The layers are an abstraction on top of the basic IsingGraph, and are the structures the user will mainly interact. Any layer in itself can be interpreted as an Ising Model with it's own properties. Currently the library supports layers that have continuous or discrete states. For both of these types a \"state set\" can be defined. For continuous layers the stateset may consist of two numbers which are interpreted as the end points of a closed interval. The states of any spin may then take on values from anywhere in this interval. For discrete states, the stateset may consist of any amount of numbers, and the spins in the system may take any of the values in the set.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can create an empty graph by calling the constructor for the IsingGraph","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"# Construct Empty Graph\ng = IsingGraph()","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"In this guide we will add everything step by step, but there are additional constructors to instantiate a graph with layers in place already. See IsingGraphs for more information.","category":"page"},{"location":"man/usage/#Adding-Layers","page":"General Usage","title":"Adding Layers","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can add layers one by one in the following way","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"#addLayer!(len, width, height = nothing; set, type)\n#Add a 2D layer\naddLayer!(g, 250,250, set = (-1,1), type = Continuous)\n...","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The exlamation mark denotes that this function is altering data in the struct it is being passed (in this case the graph g), as per general convention. The argument height is optional, and if not the function produces a 2D layer. The arguments behind the semicolon ';' are keyword arguments that have to be explicitly given by writing the name followed by an equals sign like shown.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"By default, these layers have no connections internally or to other layers.","category":"page"},{"location":"man/usage/#Accessing-the-layers","page":"General Usage","title":"Accessing the layers","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Now that our IsingGraph contains multiple layers, when we want to interact with the graph, we typically do so through these layers directly instead of with the graph itself (since the graph is a more abstract representation). We can access the layers of a graph through vector indexing of the graph. E.g., we can access the n-th layer of a graph as follows","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"layer_n = g[n]","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where n is some integer.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Most functions that work on an IsingGraph also work on an IsingLayer directly. However, if we refer to a spin in the graph or a spin in the layer the index we use to refer to a spin typically is different.","category":"page"},{"location":"man/usage/#Indexing-the-spins","page":"General Usage","title":"Indexing the spins","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The final state that is updated is held in a long vector stored in the IsingGraph. The layers, then, hold references to a part of this long vector and are interpreted as 2D or 3D structures. As an example we can have an IsingGraph with 3 2D layers,","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"g equiv s_1s_N_1s_N_1 + 1  s_N_2  ","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where, for example, spins s_N_1 + 1  s_N_2 would all belong to the second layer. This second layer has a 2D dimension of L_2*W_2 = N_2 - (N_1 + 1) where we define the length L to be the vertical dimension and the width W the horizontal dimension. Thus we may interpret this part of the vector in the graph, indexed by a single index, as a 2D matrix in the layer, which we can access by giving two coordinates i,j. The coordinates correspond the the index in the following way (known in CS as column-major order): index = left( ( (i-1) mod L) + 1 + L*j right) In words when we iterate through values of i, we cycle through numbers 1 to 50, and for every value of j we add 50 to that to get the index.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"See Indexing for supporting functions.","category":"page"},{"location":"man/usage/#Generating-the-weights","page":"General Usage","title":"Generating the weights","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The connections can be generated using a WeightGenerator. A weightgenerator must be constructed using the macro @WG. A weightgenerator is a struct that can be used to get a weight based on an arbitrary function of any combination of the following arguments: [:dr, :x, :y, :z, :dx, :dy, :dz], where dr is the relative distance between two spins, x, y and z are the midpoints between two spins that a weight is connecting (counted from the left top) and dx dy and dz are the separate one dimensional, relative distances between two spins. A weight generator expects a string containing a julia anonymous function in the following way","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"# Create the weightgenerator\nwg = @WG \"(dr) -> 1/dr^2\"","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"A weightgenerator can also include additive or multiplicative noise based on arbitrary distributions. See the WeightGenerator page for more information.","category":"page"},{"location":"man/usage/#Setting-Defects","page":"General Usage","title":"Setting Defects","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"When the simulation is started, the simulation loop is aware at the start which spins may be updated. Generally this will include every spin, but we can let the simulation know it should only loop over a collection of spins, effectively freezing the others. This will cause a small performance hit, because choosing a spin from a continuous range is less expensive than choosing one from a list, but generally the effect should be small and mostly independent on the size of the list.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can set defect with the following function","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"setDefects!(g::AbstractIsingGraph, bool, idxs)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where an AbstractIsingGraph can be either an IsingGraph or an IsingLayer. I.e. spins may be set using the list index of the underlying graph, or using the list index of a specific layer.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"If bool == true, then we indicate the spins at the given indexes should be considered as defect (i.e. non-updating), whereas bool == false indicates the spins may be updated again.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"In some sense the list of defects may be considered as metadata, meaning that it's just information that may be used by an algorithm, but doesn't neccesarily have to be used. In other words, the specific algorithm being used may still update the defect spins, or for example use the list of defects to apply a different type of update to those spins. It all depends on how the algorithm is implemented to use this data.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We may directly set spins to a value and set them to be defect or conversely updating using","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"setSpins!(g::AbstractIsingGraph, idx::Integer, brush::Real, clamp::Bool = false)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"For more information see Defects","category":"page"},{"location":"man/usage/#Starting-the-simulation","page":"General Usage","title":"Starting the simulation","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"When the graph is updated using the built in simulation, it refers to a simulation struct that's held in the module. A user typically doesn't need to interact with this struct directly. It holds data for the windows that are open, the multiple threads being used for simulation loops on a single graph or multiple different ones, etc.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Now that we have set up the graph, we typically start a simple simulation with the following function","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"simulate(g::IsingGraph, gui = true)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where the optional keyword argument gui may be given to opt out of starting the graphical user interface (this may be useful if custom display options need to be used).","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The interface, and handling of julia commands all run on a separate thread from the simulation loop itself. Any updating algorithm is typically run on a separate thread on the computer, which updates the graph asynchronously. I.e. in this setup a user will not be sure exactly on which loop interaction will happen.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Any of the algorithms that are deployed, depend on a so called loop function. At this moment the only loop function is the mainLoop function, which is just a loop that runs indefinitely. Support for a loop function that loops for a predefined number of iterations after which it will run given analysis functions, will be added. For more information on how the loops work, see Loops","category":"page"},{"location":"man/usage/#Interacting-with-the-simulation-loop","page":"General Usage","title":"Interacting with the simulation loop","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Once we have a simulation running, we might want to pause, restart it with different parameters or a different algorithm or stop it completely for a while.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Generally we can pause using the function","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"pause(g)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"after which it can be resumed with","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"unpause(g)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can also completely quit the simulation though this is generally not recommended","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"quit(g)","category":"page"},{"location":"man/usage/#Interacting-with-parameters","page":"General Usage","title":"Interacting with parameters","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Hamiltonians, and sometimes the algorithms themselves, might have parameters that either have a physical interpretation or some technical interpretation in terms of the simulation itself. Moreover, these parameters might be accesible to the user to change during runtime, like the magnetic field on the spins, or a clamping factor for equilibrium propagation.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Parameters will be either of scalar of vector value. In the case of a vector value, every index of the vector will correspond one-to-one to a spin.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Since the parameters that are in the graph will depend on the simulation loop and hamiltonian, all of which can be changed during runtime, they are not put in place when the graph is created (this might change), but rather when the simulation is started. Every time a simulation is started or restarted, the simulation loop will check if all the neccesary parameters are in place.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"These parameters may all be accesed through the accessor function params(g). This will print out a list of parameters, which are referred to by a julia symbol, along with an explanation, whether it should be used by a simulation loop, and what its current value is (it may be scalar or vector valued).","category":"page"},{"location":"man/usage/#Default-values","page":"General Usage","title":"Default values","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Since accessing memory is generally costly in computation time, acessing many parameters will generally cause a simulation loop to slow down. In other words, even if for some simulation a magnetic field is never considered, having the option to set a magnetic field would cause a slow down regardless of wether it is used. This is why these parameters are wrapped in a ParamVal type, which holds extra information, i.e. what a default global value is for the parameter in question, and wether it should be considered in the simulation.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Using Julias metaprogramming capabilities simulation loops may substitute the global value for a parameter into the loop itself instead of acessing memory, in the case where a parameter is noted as not being active. This has a downside, in that the simulation needs to be paused and recompiled when the active status of a parameter is changed, or the global value it has. In other words, we made a trade-off between simulation speed and startup/restart time, in favor of simulation speed. In the most optimal case, this also causes extra overhead when writing new simulation loops or Hamiltonians, since metaprogramming is needed. However, a simulation loop may opt out of using the active status of a parameter altogether, so that prototyping new algorithms still has the same amount of overhead.","category":"page"},{"location":"man/usage/#Setting-and-getting-parameters","page":"General Usage","title":"Setting and getting parameters","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Since the parameters contain information in their types for the simulation to use, which requires recompilation of the loop if changed, it is generally not advised to directly change the data in the parameters itself. Instead we provide the function setParam!, which automatically handles recompilation of running loops.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"setParam!(g::AbstractIsingGraph, param::Symbol, val::T, active::Bool = nothing)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"where T either is either of the same type of the value of the parameter itself, or in the case that the ParamVal holds a vector value, it may be of the element type of that vector, in which case the whole vector is globally set to the same value. In the latter case the user may also opt to deactivate the param and set a global value. This is only advised if the value is not changed often, since every change then causes recompilation of the loop. param here is a julia symbol that refers to the parameter that the user wants to change. g can be a graph or a layer, which only matters for vector values. In the layer case, we may give a scalar, a vector or a matrix as val. If a scalar is given it sets a every value corresponding to a spin in that layer to the same value when a scalar is given. For a vector, the function expects a vector with length equal to the number of spins in the layer. Lastly, for the matrix, it must be of the same size of the layer.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Finally if the optional argument active is given it will change wether value of that parameter should be accessed during runtime in the simulation loop. If this argument is not provided, it will keep the previous active status.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"To immediately get the parameter of corresponding to a symbol, we can use","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"getParam(g::AbstractIsingGraph, param::Symbol)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"See Parameters for more information.","category":"page"},{"location":"man/usage/#Algorithms-and-Hamiltonians","page":"General Usage","title":"Algorithms and Hamiltonians","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Hamiltonians in this package are an abstract description of an energy function in terms of Julia symbols. They don't have any inherent code, and are only meant to symbolize the existense of that Hamiltonian in this package. The reason for this is the following: we want to support many different algorithms. These algorithms may require different quantities/functions derived from the Hamiltonian (such as a difference when changing the state of one unit or a derivative). Hardcoding the code for a Hamiltonian would not be efficient, and automating rewriting, or deriving quantities would still not give optimal performance, apart from being nigh impossible to implement for every algorithm.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Instead we have a system where the writer of an algorithm needs to implement a custom piece of code that implements the Hamiltonian for the specific algorithm. It is thus up to the writer of an algorithm to implement Hamiltonians.","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"For the user, different algorithms and Hamiltonians can be chosen. Moreover, algorithms can also implement composite Hamiltonians (H_tot = H_1 + H_2 + ). ","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"We can set a default algorithm to run when a new simulation is started (which can be manually overwritten when starting the simulation as well)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"default_algorithm(g, LayeredMetropolis)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"A new Hamiltonian can be set the following way","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"hamiltonian(g,Ising)","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"A composite Hamiltonian can be constructed from","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"CompositeHamiltonian(Ising,Clamping)","category":"page"},{"location":"man/usage/#Algorithms","page":"General Usage","title":"Algorithms","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"The following algorithms are currently Implemented","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Metropolis: The normal metropolis algorithm. This algorithm treats every layer to be of the same type as layer 1.\nLayeredMetropolis: An algorithm that implements a different algorithm for every layer based on the layer type. Due to metaprogramming it just reduces to the normal metropolis when all layers are of a single type.\nSoon: Langevin","category":"page"},{"location":"man/usage/#Hamiltonians","page":"General Usage","title":"Hamiltonians","text":"","category":"section"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Currently the following Hamiltonians are implemented","category":"page"},{"location":"man/usage/","page":"General Usage","title":"General Usage","text":"Ising: The Ising Hamiltonian H = - sum_ij sigma_i sigma_j -sum_i b_i sigma_i   where b is the magnetic field at every spin\nClamping: A Clamping Hamiltonian for Equilibrium Propagation H = β2 *(s_i - y_i)^2   where y_i is a target value for the n-th spin\nGaussianBernoulli: The Gaussian Bernoulli Hamiltonian often used with RBM's ","category":"page"},{"location":"man/WeightGenerator/#WeightGenerator","page":"WeightGenerators","title":"WeightGenerator","text":"","category":"section"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"Weight generators are structs that use some metaprogramming to turn a description of a function dependent on coordinates in the lattice of an IsingLayer into a weight. The details of weightgenerators may change, but the interface should remain fairly stable.","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"A WeightGenerator holds descriptions of the following things:","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"A julia anonymous function that describes how to generate the weight from the following arguments:   [dr,dx,dy,dz,x,y,z] where dr is the relative distance between two spins, dx, dy, dz are displacements in the x, y and z coordinates respectively   x, y, z are the averaged coordinate of the two spins, starting at one at the top left of a lattice, where y counts up going downwards.\nThe function given may accept any combination of these coordinates\nA julia anonymous function describing how to generate the self energy of a spin (i.e. J_ii) from the following arguments:   [x, y, z] which are the lattice coordinates of a spin.\nA description of a distribution from which a number is sampled which is added to the generated weight.   I.e. Normal(μ,σ) would add a random number generated from a normal distribution with mean μ and standard deviation σ to the weight generated from the function above.","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"A description of a distribution from which a number is sampled which is multiplied with the generated weight.   I.e. using [-1,1], a random sign can be will be sampled with equal probability which is mulitplied with the weight.\nThe amount of nearest neighbors for which a weight needs to be generated. This number, let's call it NN will cause the algorithm to generate weights for a NN*NN or NN*NN*NN square block (in matrix coordinates, not real distance).   At first sight this might seem redundant, because we can program a distance cutoff in the generating function that we supply, i.e. (dr) -> dr < 3 ? somefunc(dr) : 0 which ensures that all weights for distances greater than 3 are zero. However, julia code cannot know beforehand wether some arbitrary function causes a distance cutoff. Thus, all combinations of spins would need to be checked to see if they produce a zero weight. This is computationally prohibitive because of combinatorial explosion. Thus the computation time of generating an adjacency list is very roughly on the order of N_spins^d * NN^d instead of (N_spins^d)^2, where typically NN^d  N_spins^d.","category":"page"},{"location":"man/WeightGenerator/#Why-Metaprogramming?","page":"WeightGenerators","title":"Why Metaprogramming?","text":"","category":"section"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"Metaprogramming allows for flexible definition of the weights, like choosing which arguments are neccesary and chooshing whether or not to have a self energy or distirbution term, while still being performant. A user can now just write (dx, dy) -> somefunc(dx,dy) which will be handled by the metaprogramming code. If metaprogramming wouldn't be used, any description of the function would need to include all possible arguments, even if they are not used (dr,dx,dy,dx,x,y,z) -> somefunc(dx,dy) to ensure consistent working with the functions in the module that generate the adjacency lists from these weights.","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"Performance is also key because the amount of weights generated for even a simple lattice might otherwise already be prohibitive in terms of computation time.","category":"page"},{"location":"man/WeightGenerator/#Constructing-WeightGenerators","page":"WeightGenerators","title":"Constructing WeightGenerators","text":"","category":"section"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"Because we need metaprogramming capabities, weightgenerators are not generated through a normal julia function, but a macro, @WG, which returns a regular julia struct. It accepts the following","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"wg = @WG \"(args) -> somefunc(...)\" selfWeight = \"(selfargs) -> someselffunc(...)\" addDist = \"Dist(...)\" multDist = \"Dist(...)\" NN = 3","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"Where args is any combination of the arguments [dr, dx, dy, dz, x, y, z], and selfargs is any combination of [x,y,z]. For the interpretations of the arguments see the first section WeightGenerator.","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"The first argument and the keyword argument are required. Except for the argument NN, which is given as an int, all other arguments are given as strings, otherwise containing normal julia code.","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"The distributions may be given in two ways. The first is to provide any julia code that may be filled into rand. I.e. Normal(μ,σ) may be used as rand(Normal(μ,σ)) to generate numbers from a normal distribution, or [-1,1] may be used as rand([-1,1]) to generate an integer from that list with equal probability. We may also give any rand(...) function directly, for example to produce numbers from a list with inhomogeneous probability.","category":"page"},{"location":"man/WeightGenerator/#Redundancy","page":"WeightGenerators","title":"Redundancy","text":"","category":"section"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"There is a bit of redundancy built in for convenience's sake. The addDist and multDist arguments provide global distributions which also could have been given through the weight generating function itself. This however keeps the code a bit cleaner and easier to read.","category":"page"},{"location":"man/WeightGenerator/#Getting-the-weight","page":"WeightGenerators","title":"Getting the weight","text":"","category":"section"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"We can get the weight from a weightgenerator with","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"getWeight(wg::WeightGenerator; dr = 0, dx = 0, dy = 0, dz = 0, x = 0, y = 0, z = 0)","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"where the arguments not used by the function given during construction simply have no effect.","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"We can get the self weight with","category":"page"},{"location":"man/WeightGenerator/","page":"WeightGenerators","title":"WeightGenerators","text":"getSelfWeight(wg::WeightGenerator; x = 0, y = 0, z = 0)","category":"page"},{"location":"man/Loops/#Loops","page":"Loops","title":"Loops","text":"","category":"section"},{"location":"man/Analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"}]
}
