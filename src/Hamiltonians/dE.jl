struct SIMDCheck{T} end

using Mixers
"""
Main function that generated the expression for the energy factor term
This factor is used for the generated function below
The reason this is a seperate function is for debugging
"""

@pour connections nzrange(gadj, idx)
@pour weight gadj.nzval[ptr]
@pour conn_s gstate[gadj.rowval[ptr]]

@inline conn_range(adj::SparseMatrixCSC, idx) = nzrange(adj, idx)
@inline getweight(adj::SparseMatrixCSC, ptr) = adj.nzval[ptr]
@inline conn_idx(adj::SparseMatrixCSC, ptr) = adj.rowval[ptr]


# const unweighted_expr_sp = "-gstate[conn_idx(gadj,ptr)]"
const weighted_expr_sp = "-(@conn_s) * @weight"

const unweighted_expr_sp = "-gstate[gadj.rowval[ptr]]"
# const weighted_expr_sp = "-gstate[gadj.rowval[ptr]] * gadj.nzval[ptr]"
const mag_expr = "-bfield(g)[idx]"
const check_empty = Observable{String}("true")
on(check_empty) do val
    invalidate(getdE)
end
function toggle_check_empty()
    if check_empty[] == "true"
        check_empty[] = "false"
    else
        check_empty[] = "true"
    end
end

export check_empty, toggle_check_empty

function expr_dEIsing(::Any)
    return nothing
end

function expr_dEIsing(stype::Type{<:SType}) 
    weighted = getSParam(stype, :Weighted)
    magfield =  getSParam(stype, :Magfield)

    # @turbo check_empty = $T for idx in nzrange(gadj, idx)

    expr = "begin
        efactor = zero(T)
        @turbo check_empty = $(check_empty[]) for ptr in @connections
            efactor += $(weighted ? weighted_expr_sp : unweighted_expr_sp) 
        end
        return efactor $(magfield*mag_expr)
    end"

    return Meta.parse(expr)
end
expr_dEIsing(st::SType) = expr_dEIsing(typeof(st))
export expr_dEIsing


#= Main Energy Factor Function =#
"""
Get the energy factor (where we define E === σ_i Σ_j fac_j) for the state
the function is dispatched on the graph g, the idx i and the type of the Hamiltonian
which may be generated by the function HType(Symbs...).
"""
@generated function dEIsing(g::IsingGraph{T}, gstate, gadj::SparseMatrixCSC, idx, stype::SType) where T

    exp = expr_dEIsing(stype)

    return exp
end
dEIsing(g, idx) = dEIsing(g, state(g), sp_adj(g), idx, stype(g)) 

export dEIsing


function dEIsing(g::IsingGraph{T}, gstate, gadj::Vector{Vector{Tuple{Int32, Float32}}}, idx, stype::SType) where T
    efac = zero(T)
    conns = gadj[idx]
    @fastmath for conn in conns
        c_idx = conn[1]
        weight = conn[2]
        efac += -gstate[c_idx]*weight
    end
    return efac
end

using CodeTracking
function invalidate(::typeof(dEIsing))
    expr = quote
        @generated function getdE(g, gstate, gadj::SparseMatrixCSC, idx, stype::SType)::Float32

            exp = expr_dEIsing(stype)
        
            return exp
        end
    end
    Core.eval(@__MODULE__, expr)
end
export invalidate